"use strict";(self.webpackChunkcompile_time_printer=self.webpackChunkcompile_time_printer||[]).push([[143],{8886:(t,e,n)=>{n(9317),n(6180),n(8143),n(5623),n(236),n(1387),n(4367),n(2102),n(5833),n(7885),n(5729),n(9431),n(3365),n(3740),n(1895),n(6022),n(1633),n(8370),n(4125),n(1097),n(874),n(184),n(628),n(2470),n(9427),n(6353),n(4602),n(5766),n(7253),n(7061),n(5313),n(3598),n(1934),n(102),n(8762),n(4804),n(4662),n(9607),n(1271),n(943),n(7181),n(6709),n(9477),n(9646),n(7830),n(8956),n(3588),n(8766),n(8944),n(5048),n(5662);var r=n(1327);n(9540);self.MonacoEnvironment={getWorkerUrl:function(t,e){const n=performance.getEntriesByType("resource");for(const t of n)if(t.name.includes("editor.worker"))return t.name}};const i=r.editor.create(document.getElementById("editor"),{value:"",language:"cpp",fontFamily:'Consolas, "Liberation Mono", Courier, monospace',scrollBeyondLastLine:!0,quickSuggestions:!1,folding:!0,lineNumbersMinChars:1,emptySelectionClipboard:!0,automaticLayout:!0}),a='/*\n *  Compile-Time Printer\n *  ----------------------------------------------------------\n *  Copyright 2021 Toni Neubert. All rights reserved.\n *\n *  Distributed under the Boost Software License, Version 1.0.\n *  (See accompanying file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n */\n#ifndef COMPILE_TIME_PRINTER_HPP_INCLUDE\n#define COMPILE_TIME_PRINTER_HPP_INCLUDE\n\n// If defined, don\'t print anything.\n// #define CTP_QUIET\n// If defined, don\'t even print version indicator.\n// #define CTP_DEAD_QUIET\n\n#if defined(CTP_DEAD_QUIET) && !defined(CTP_QUIET)\n    #define CTP_QUIET\n#endif\n\n#if defined(__clang__) || !defined(__GNUC__) || defined(__INTEL_COMPILER) || __cplusplus < 201703L\n    #if !defined(CTP_QUIET)\n        #define CTP_QUIET\n        #error "Only GCC >= 7, STD >= C++17 is supported."\n    #endif\n#endif\n\n#include <array>\n#include <string_view>\n#include <tuple>\n\n#include <cmath>\n#include <cstddef>\n#include <cstdint>\n\nnamespace ctp {\n\n/**\n * Represents a file descriptor.\n */\nstruct file_descriptor {\n\tsize_t value;\n\tconstexpr bool operator==(const file_descriptor& other) const;\n};\n\n/// Standard output stream (stdout).\ninline constexpr file_descriptor stdout{1};\n\n/// Standard error output stream (stderr).\ninline constexpr file_descriptor stderr{2};\n\n/**\n * Prints all arguments in a simple, standardized format.\n * Each argument is separated by one space, ending with a line break.\n * @param args - the arguments to print.\n */\ntemplate<typename... Args>\nconstexpr auto print(Args&&... args);\n\n/**\n * Prints all arguments in a simple, standardized format to a specific file  descriptor.\n * Each argument is separated by one space, ending with a line break.\n * @param fd - the file descriptor\n * @param args - the arguments to print\n */\ntemplate<typename FileDescriptor,\n         typename... Args,\n         std::enable_if_t<std::is_same_v<std::decay_t<FileDescriptor>, file_descriptor>>* = nullptr>\nconstexpr auto print(FileDescriptor&& fd, Args&&... args);\n\n/**\n * Formats and prints all arguments in the desired format.\n * @param args - the arguments to format and print\n */\ntemplate<typename... Args>\nconstexpr auto printf(std::string_view format = "", Args&&... args);\n\n/**\n * Formats and prints all arguments in the desired format to a specific file descriptor.\n * @param fd - the file descriptor\n * @param args - the arguments to format and print\n */\ntemplate<typename FileDescriptor,\n         typename... Args,\n         std::enable_if_t<std::is_same_v<std::decay_t<FileDescriptor>, file_descriptor>>* = nullptr>\nconstexpr auto printf(FileDescriptor&& fd, std::string_view format = "", Args&&... args);\n\n/**\n * For user-defined types, the format function of the specialized formatter<T> struct template is used.\n * Provide a function `constexpr auto format(T);` returning a tuple like object. The first element must be a format\n * string followed by the arguments.\n * @tparam T - the user-defined type\n */\ntemplate<typename T>\nstruct formatter;\n\n/**\n * Helper to print a contiguous range.\n * @tparam T - the value type of the range\n */\ntemplate<typename T>\nclass view;\n\n/**\n * Helper to print the types of arguments rather than the values.\n * @tparam Ts - the types to print\n */\ntemplate<typename... Ts>\nstruct type;\n\n/**\n * Helper to generate extra noise to force the compiler not to cache the evaluation of a print statement.\n * Should be taken by reference.\n */\nstruct noise {};\n\nnamespace detail {\n\n/// Forward a value.\ntemplate<typename T, std::enable_if_t<!std::is_invocable_v<T>>* = nullptr>\nconstexpr T forward(T&& value) {\n\treturn value;\n}\n\n/// Forward the return value of a function.\ntemplate<typename T, typename... Ts, std::enable_if_t<std::is_invocable_v<T, Ts...>>* = nullptr>\nconstexpr auto forward(T&& func, Ts&&... args) {\n\treturn func(std::forward<Ts>(args)...);\n}\n\n}    // namespace detail\n\n/**\n * Helper to use print/printf in static_assert and template parameters.\n * The expression/function will be instantiated as constexpr variable, to overcome compile errors.\n * @tparam ExprFunc - the expression or function which should be instantiated\n * @tparam Args - the arguments for the function\n */\ntemplate<auto ExprFunc, auto... Args>\ninline constexpr auto forward = detail::forward(std::forward<decltype(ExprFunc)>(ExprFunc),\n                                                std::forward<decltype(Args)>(Args)...);\n\nnamespace detail {\n\ninline constexpr auto protocol_version = 1;\n\nenum class Indicator : uint32_t {\n\tVersion = 32,\n\tStartOut = 33,\n\tStartErr = 34,\n\tStartOutFormat = 35,\n\tStartErrFormat = 36,\n\tEnd = 37,\n\tNaNFloat = 128,\n\tPositiveInfinityFloat = 129,\n\tNegativeInfinityFloat = 130,\n\tNegativeFloat = 131,\n\tPositiveFloat = 132,\n\tFractionFloat = 133,\n\tPositiveInteger = 134,\n\tNegativeInteger = 135,\n\tType = 136,\n\tArrayBegin = 138,\n\tArrayEnd = 139,\n\tStringBegin = 140,\n\tStringEnd = 141,\n\tTupleBegin = 142,\n\tTupleEnd = 143,\n\tCustomFormatBegin = 144,\n\tCustomFormatEnd = 145,\n};\n\ntemplate<typename T, std::enable_if_t<std::is_arithmetic_v<T>>* = nullptr>\nconstexpr __uint128_t to_abs_int(T value) {\n\tif constexpr (std::is_signed_v<T>) {\n\t\treturn static_cast<__uint128_t>(std::abs(value));\n\t} else {\n\t\treturn static_cast<__uint128_t>(value);\n\t}\n}\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored "-Wshift-count-overflow"\n\n#ifdef CTP_QUIET\n#define CTP_INTERNAL_PRINT(x, y)              \\\n\t{                                         \\\n\t\t[[maybe_unused]] auto unused_x = (x); \\\n\t\t[[maybe_unused]] auto unused_y = (y); \\\n\t}\n#else\n#define CTP_INTERNAL_PRINT(x, y) \\\n\t{ [[maybe_unused]] auto unused = (x) << static_cast<uint32_t>(y); }\n#endif\n\n/// Print integer values.\ntemplate<typename T, typename... Args, std::enable_if_t<std::is_integral_v<T>>* = nullptr>\nconstexpr void print_value(int& /*unused*/, T value, Args&&... /*unused*/) {\n\tif constexpr (std::is_signed_v<T>) {\n\t\tif (value < 0) {\n\t\t\tCTP_INTERNAL_PRINT(to_abs_int(value), Indicator::NegativeInteger);\n\t\t} else {\n\t\t\tCTP_INTERNAL_PRINT(to_abs_int(value), Indicator::PositiveInteger);\n\t\t}\n\t} else {\n\t\tCTP_INTERNAL_PRINT(to_abs_int(value), Indicator::PositiveInteger);\n\t}\n}\n\n/// Print floating point values.\ntemplate<typename T, typename... Args, std::enable_if_t<std::is_floating_point_v<T>>* = nullptr>\nconstexpr void print_value(int& one, T value, Args&&... /*unused*/) {\n\tif (value != value) {\n\t\tCTP_INTERNAL_PRINT(one, Indicator::NaNFloat);\n\t\treturn;\n\t}\n\tif (value < 0) {\n\t\tif (std::abs(value) == std::numeric_limits<long double>::infinity()) {\n\t\t\tCTP_INTERNAL_PRINT(one, Indicator::NegativeInfinityFloat);\n\t\t\treturn;\n\t\t}\n\t\tCTP_INTERNAL_PRINT(to_abs_int(value), Indicator::NegativeFloat);\n\t} else if (value >= 0) {\n\t\tif (value == std::numeric_limits<long double>::infinity()) {\n\t\t\tCTP_INTERNAL_PRINT(one, Indicator::PositiveInfinityFloat);\n\t\t\treturn;\n\t\t}\n\t\tCTP_INTERNAL_PRINT(to_abs_int(value), Indicator::PositiveFloat);\n\t}\n\tlong double decimal = value;\n\tauto fraction = std::abs(decimal) - std::floor(std::abs(decimal));\n\tfraction *= std::pow(10.0L, std::numeric_limits<long double>::digits10);\n\tCTP_INTERNAL_PRINT(to_abs_int(fraction), Indicator::FractionFloat);\n}\n\n/// Print contiguous sequences of not char-like objects.\ntemplate<\n  typename T,\n  typename... Args,\n  std::enable_if_t<!std::is_convertible_v<T, std::string_view> && sizeof(decltype(view(std::declval<T>())))>* = nullptr>\nconstexpr void print_value(int& one, T&& value, Args&&... args) {\n\tCTP_INTERNAL_PRINT(one, Indicator::ArrayBegin);\n\tfor (auto v : view(value)) {\n\t\tprint_value(one, v, std::forward<Args>(args)..., v, value);\n\t}\n\tCTP_INTERNAL_PRINT(one, Indicator::ArrayEnd);\n}\n\n/// Print contiguous sequence of char-like objects.\ntemplate<typename T, typename... Args, std::enable_if_t<std::is_convertible_v<T, std::string_view>>* = nullptr>\nconstexpr void print_value(int& one, T value, Args&&... args) {\n\tCTP_INTERNAL_PRINT(one, Indicator::StringBegin);\n\tfor (auto v : std::string_view{value}) {\n\t\tprint_value(one, v, std::forward<Args>(args)..., v, value);\n\t}\n\tCTP_INTERNAL_PRINT(one, Indicator::StringEnd);\n}\n\n/// Print tuple like.\ntemplate<size_t... Is, typename T, typename... Args>\nconstexpr void print_value(int& one, std::index_sequence<Is...> /*unused*/, T&& tuple, Args&&... args) {\n\tCTP_INTERNAL_PRINT(one, Indicator::TupleBegin);\n\t(print_value(one, std::get<Is>(std::forward<T>(tuple)), std::forward<Args>(args)..., Is, Is...), ...);\n\tCTP_INTERNAL_PRINT(one, Indicator::TupleEnd);\n}\n\ntemplate<typename T>\nstruct is_not_std_array : std::true_type {};\n\ntemplate<typename T, size_t N>\nstruct is_not_std_array<std::array<T, N>> : std::false_type {};\n\ntemplate<typename T>\nstruct is_complete {\nprivate:\n\ttemplate<typename U>\n\tstatic int is_complete_helper(int (*)[sizeof(U)]);\n\ttemplate<typename>\n\tstatic char is_complete_helper(...);\n\npublic:\n\tstatic constexpr bool value = sizeof(is_complete_helper<T>(0)) != 1;\n};\n\ntemplate<typename T>\nstruct is_tuple_like :\n  std::integral_constant<bool, is_complete<std::tuple_size<T>>::value && is_not_std_array<T>::value> {};\n\n// Unpack tuple like.\ntemplate<typename T, typename... Args, std::enable_if_t<is_tuple_like<std::decay_t<T>>::value>* = nullptr>\nconstexpr void print_value(int& one, T&& tuple, Args&&... args) {\n\tprint_value(one,\n\t            std::make_index_sequence<std::tuple_size_v<std::decay_t<T>>>{},\n\t            std::forward<T>(tuple),\n\t            std::forward<Args>(args)...);\n}\n\n/// Print type.\ntemplate<typename... Ts, typename... Args>\nconstexpr void print_value(int& one, type<Ts...>, Args&&... /*unused*/) {\n\tCTP_INTERNAL_PRINT(one, Indicator::Type);\n}\n\n/// Generate noise.\ntemplate<typename... Args>\nconstexpr void print_value(int&, const noise&, Args&&... /*unused*/) {}\n\n/// Print with user-defined formatter.\ntemplate<typename T,\n         typename... Args,\n         std::enable_if_t<sizeof(std::string_view{std::get<0>(std::declval<ctp::formatter<std::decay_t<T>>>().format(\n                            std::declval<T>()))}) == 16>* = nullptr>\nconstexpr void print_value(int& one, T&& value, Args&&... args) {\n\tCTP_INTERNAL_PRINT(one, Indicator::CustomFormatBegin);\n\tprint_value(one, formatter<std::decay_t<T>>{}.format(value), std::forward<Args>(args)...);\n\tCTP_INTERNAL_PRINT(one, Indicator::CustomFormatEnd);\n}\n\n/// Print start indicator output stream and if first argument is the format string.\ntemplate<bool Format, typename Arg, typename... Args>\nconstexpr void print_start_indicator(int& one, Arg&& arg, Args&&...) {\n\tif constexpr (std::is_same_v<std::decay_t<Arg>, file_descriptor>) {\n\t\tif (arg == stderr) {\n\t\t\tif (Format) {\n\t\t\t\tCTP_INTERNAL_PRINT(one, Indicator::StartErrFormat);\n\t\t\t} else {\n\t\t\t\tCTP_INTERNAL_PRINT(one, Indicator::StartErr);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tif (Format) {\n\t\tCTP_INTERNAL_PRINT(one, Indicator::StartOutFormat);\n\t} else {\n\t\tCTP_INTERNAL_PRINT(one, Indicator::StartOut);\n\t}\n}\n\n/// Print end indicator.\ntemplate<typename... Args>\nconstexpr auto print_end_indicator(int one, Args&&... /*unused*/) {\n\tCTP_INTERNAL_PRINT(one, Indicator::End);\n\treturn one;\n}\n\n/// Trigger unused variable instead of fpermissive warning to be compatible to other compiler in the future.\n#pragma GCC diagnostic push\n#pragma GCC diagnostic warning "-Wunused-variable"\ntemplate<int Version>\nconstexpr auto print_protocol_version() {\n#ifndef CTP_DEAD_QUIET\n\tint version = Version;\n#endif\n\treturn Version;\n}\n#pragma GCC diagnostic pop\n\ninline constexpr auto indicate_protocol_version = print_protocol_version<protocol_version>();\n\n#pragma GCC diagnostic pop\n\ninline constexpr struct separator_t {\n} separator;\n\n/// Unpack and print each argument.\ntemplate<size_t... Is, typename... Args>\nconstexpr void print_helper(int& one, std::index_sequence<Is...> /*unused*/, Args&&... args) {\n\t// First parameter (unpacked by ...) is the value to print.\n\t// The separator is used to better parse the type of the first parameter from the variadic template list. All other\n\t// parameters and the index sequence are unused but otherwise same arguments are mentioned only once.\n\t(print_value(one, std::forward<Args>(args), separator, std::forward<Args>(args)..., Is, Is...), ...);\n}\n\ntemplate<bool Format,\n         typename Arg = ctp::noise,\n         typename... Args,\n         std::enable_if_t<!std::is_same_v<std::decay_t<Arg>, file_descriptor> ||\n                          (std::is_same_v<std::decay_t<Arg>, file_descriptor> && sizeof...(Args) > 0)>* = nullptr>\nconstexpr auto print(Arg&& arg = {}, Args&&... args) {\n\tint one = 1;\n\tprint_start_indicator<Format>(one, std::forward<Arg>(arg), std::forward<Args>(args)...);\n\n\t/// Skip first argument if file descriptor.\n\tif constexpr (std::is_same_v<std::decay_t<Arg>, file_descriptor>) {\n\t\tprint_helper(one, std::make_index_sequence<sizeof...(Args)>{}, std::forward<Args>(args)...);\n\t} else {\n\t\tprint_helper(\n\t\t  one, std::make_index_sequence<sizeof...(Args) + 1>{}, std::forward<Arg>(arg), std::forward<Args>(args)...);\n\t}\n\n\treturn print_end_indicator(one, std::forward<Arg>(arg), std::forward<Args>(args)...);\n}\n\n}    // namespace detail\n\nconstexpr bool file_descriptor::operator==(const file_descriptor& other) const {\n\treturn value == other.value;\n}\n\ntemplate<typename... Args>\nconstexpr auto print(Args&&... args) {\n\treturn detail::print<false>(std::forward<Args>(args)...);\n}\n\ntemplate<typename FileDescriptor,\n         typename... Args,\n         std::enable_if_t<std::is_same_v<std::decay_t<FileDescriptor>, file_descriptor>>*>\nconstexpr auto print(FileDescriptor&& stream, Args&&... args) {\n\treturn detail::print<false>(std::forward<FileDescriptor>(stream), std::forward<Args>(args)...);\n}\n\ntemplate<typename FileDescriptor,\n         typename... Args,\n         std::enable_if_t<std::is_same_v<std::decay_t<FileDescriptor>, file_descriptor>>*>\nconstexpr auto printf(FileDescriptor&& stream, std::string_view format, Args&&... args) {\n\treturn detail::print<true>(std::forward<FileDescriptor>(stream), format, std::forward<Args>(args)...);\n}\n\ntemplate<typename... Args>\nconstexpr auto printf(std::string_view format, Args&&... args) {\n\treturn detail::print<true>(stdout, format, std::forward<Args>(args)...);\n}\n\ntemplate<typename T>\nclass view {\npublic:\n\ttemplate<typename, typename = void>\n\tstruct has_size_and_data : std::false_type {};\n\n\ttemplate<typename U>\n\tstruct has_size_and_data<\n\t  U,\n\t  std::void_t<decltype(std::size(std::declval<U>())), decltype(std::data(std::declval<U>()))>> : std::true_type {};\n\n\tconstexpr view() = default;\n\n\ttemplate<size_t N>\n\texplicit constexpr view(const std::array<T, N>& arr) : data_{arr.data()}, size_{arr.size()} {}\n\n\ttemplate<size_t N>\n\texplicit constexpr view(const T (&arr)[N]) : data_{arr}, size_{N} {}\n\n\ttemplate<typename U, std::enable_if_t<has_size_and_data<U>::value>* = nullptr>\n\texplicit constexpr view(const U& arr) : data_(arr.data()), size_{arr.size()} {}\n\n\ttemplate<typename U, std::enable_if_t<std::is_integral_v<U>>* = nullptr>\n\tconstexpr view(const T* first, U&& size) : data_{first}, size_{static_cast<size_t>(size)} {}\n\n\tconstexpr view(const T* first, const T* last) : data_{first}, size_{static_cast<size_t>(last - first)} {}\n\n\tconstexpr auto begin() const {\n\t\treturn data_;\n\t}\n\n\tconstexpr auto end() const {\n\t\treturn data_ + size_;\n\t}\n\nprivate:\n\tconst T* data_{};\n\tsize_t size_{};\n};\n\ntemplate<typename T, size_t N>\nview(std::array<T, N>) -> view<T>;\n\ntemplate<typename T, size_t N>\nview(T (&)[N]) -> view<T>;\n\ntemplate<typename T>\nview(T) -> view<std::remove_pointer_t<decltype(std::data(std::declval<T>()))>>;\n\ntemplate<typename T>\nview(T*, T*) -> view<T>;\n\ntemplate<typename T, typename U>\nview(T*, U) -> view<T>;\n\ntemplate<typename... Ts>\nstruct type {\n\tconstexpr type() = default;\n\n\tconstexpr type(Ts&&... /*unused*/) {}\n};\n\ntemplate<typename... Ts>\ntype(Ts&&...) -> type<Ts...>;\n\n}    // namespace ctp\n\n#endif    // COMPILE_TIME_PRINTER_HPP_INCLUDE\n';let o=null;const s=loadPyodide().then((t=>{t.globals.set("__name__","module"),t.runPython("import argparse\nimport datetime\nimport math\nimport pkgutil\nimport re\nimport subprocess\nimport sys\nfrom enum import IntEnum\nfrom pathlib import Path\n\ntry:\n    from compile_time_printer import __version__\nexcept ImportError:\n    __version__ = 'unknown'\n\n__author__ = 'Toni Neubert'\n__copyright__ = 'Copyright 2021 %s' % __author__\n__license__ = 'BSL-1.0'\n\nfrom typing import List, TextIO, Iterator\n\nPROTOCOL_VERSION = 1\nPROTOCOL_VERSION_INDICATOR_RE = re.compile(\n    r'In instantiation of .constexpr auto ctp::detail::print_protocol_version\\(\\) \\[with int Version = (\\d+)]')\nSTART_INDICATOR_RE = re.compile(r' in .?constexpr.? expansion of .ctp::detail::print_start_indicator<')\nEND_INDICATOR_RE = re.compile(r' in .?constexpr.? expansion of .ctp::detail::print_end_indicator<')\nPRINT_INDICATOR_RE = re.compile(\n    r'^.+in .?constexpr.? expansion of .ctp::detail::print_value<(.+?), const (ctp::detail::)?separator_t&.+$')\nVALUE_INDICATOR_RE = re.compile(r'right operand of shift expression .\\((.+?) << (.+?)\\).')\n\n# Matches for reducing warning outputs related to CTP.\nIN_EXPANSION_OF_CTP_MACRO_RE = re.compile(r'.+note: in expansion of macro .CTP_INTERNAL_PRINT.')\nIN_EXPANSION_OF_RE = re.compile(r'.+:\\s+in.+expansion.+of.+')\nIN_TEMPLATE_ARGUMENT_FOR_TYPE = re.compile(r'.+note:\\s+in template argument for type.+')\nIN_INSTANTIATION_OF_RE = re.compile(r'.+: In instantiation of.+:')\nIN_FUNCTION_RE = re.compile(r'.+: In function.+:')\nAT_GLOBAL_SCOPE_RE = re.compile(r'.+: At global scope:')\nIN_FILE_INCLUDED_RE = re.compile(r'(?:In file included|\\s{16}) from .+')\n\n\nclass Indicator(IntEnum):\n    Version = 32\n    StartOut = 33\n    StartErr = 34\n    StartOutFormat = 35\n    StartErrFormat = 36\n    End = 37\n    NaNFloat = 128\n    PositiveInfinityFloat = 129\n    NegativeInfinityFloat = 130\n    NegativeFloat = 131\n    PositiveFloat = 132\n    FractionFloat = 133\n    PositiveInteger = 134\n    NegativeInteger = 135\n    Type = 136\n    ArrayBegin = 138\n    ArrayEnd = 139\n    StringBegin = 140\n    StringEnd = 141\n    TupleBegin = 142\n    TupleEnd = 143\n    CustomFormatBegin = 144\n    CustomFormatEnd = 145\n\n\nclass TypePrettifier:\n    \"\"\"\n    Removes unwanted type information.\n    \"\"\"\n\n    def __init__(self, removes: List[str], capture_removes: List[str]):\n        \"\"\"\n        Constructor.\n        :param removes: list of regex to remove from type information\n        :param capture_removes: list of regex to remove from type information with one capture to keep\n        \"\"\"\n        self.__removes_re = [re.compile(r) for r in removes]\n        self.__capture_removes = [re.compile(r) for r in capture_removes]\n\n    def prettify(self, line):\n        for replace_re in self.__removes_re:\n            line = replace_re.sub('', line)\n        for capture_replace_re in self.__capture_removes:\n            line = capture_replace_re.sub(r'\\1', line)\n        return line\n\n\nclass PrintStatement:\n    def __init__(self, time_point: datetime.timedelta, format_str: bool, output_stream: TextIO, args: List):\n        self._time_point = time_point\n        self._format_str = format_str\n        self._output_stream = output_stream\n        self._args = args\n\n        if self._format_str:\n            # First argument is format string.\n            self._message = self._args[0].format(*self._args[1:])\n        else:\n            self._message = ' '.join(str(x) for x in self._args) + '\\n'\n\n    def serialize(self):\n        return self._message, self._output_stream == sys.stderr\n\n    def print(self, time_point: bool, colored: bool):\n        \"\"\"\n        Prints all parsed arguments.\n        :param time_point: if add timepoint to output\n        :param colored: if output should be colored\n        \"\"\"\n        string = ''\n        if time_point:\n            string += '{} - '.format(self._time_point)\n        string += self._message\n        if colored and self._output_stream == sys.stderr:\n            string = '\\033[1;31m{}\\033[0m'.format(string)\n\n        # Print statement.\n        print(string, end='', file=self._output_stream)\n\n\nclass CompilerStatement:\n    def __init__(self, message: str):\n        self._message = message\n\n    def serialize(self):\n        return self._message, True\n\n    def print(self, _1, _2):\n        print(self._message, end='', file=sys.stderr)\n\n\nclass CTP:\n    def __init__(self, type_prettifier: TypePrettifier, print_compiler_log: bool):\n        \"\"\"\n        :param print_compiler_log: flag to enable printing unparsed compiler log\n        \"\"\"\n        self._type_prettifier = type_prettifier\n        self._printers = []\n        self._print_compiler_log = print_compiler_log\n        self._compiler_log = []\n\n    @property\n    def printers(self):\n        self._process_compiler_log()\n        return self._printers\n\n    def parse_error_log(self, compiler_log: Iterator[str]) -> Iterator[PrintStatement]:\n        \"\"\"\n        Parses for print statements in the compiler log.\n        :param compiler_log: the compiler_log\n        :param type_prettifier: the type prettifier\n        :return: the print statements\n        \"\"\"\n        not_available = True\n        start_time = datetime.datetime.now()\n\n        # For debugging only:\n        # def logger():\n        #     while True:\n        #         try:\n        #             line = next(compiler_log)\n        #             print(line)\n        #             yield line\n        #         except StopIteration:\n        #             break\n        # log = logger()\n        log = compiler_log\n\n        while True:\n            try:\n                line = next(log)\n            except StopIteration:\n                break\n\n            # Find start indicator.\n            if START_INDICATOR_RE.search(line):\n                time_diff = datetime.datetime.now() - start_time\n\n                line = next(log)\n                if 'error:' in line:\n                    raise Exception('Parsing not possible. Did you forget -fpermissive?')\n                value_match = VALUE_INDICATOR_RE.search(line)\n                if value_match:\n                    start_indicator = Indicator(int(value_match[2]))\n                else:\n                    raise Exception('No valid start indicator: {}'.format(line))\n                output_stream = sys.stdout if start_indicator in [Indicator.StartOut,\n                                                                  Indicator.StartOutFormat] else sys.stderr\n                format_str = start_indicator in [Indicator.StartOutFormat, Indicator.StartErrFormat]\n                args = self._parse_print_log(log)\n\n                self._clean_compiler_log_prefix()\n                self._printers.append(PrintStatement(time_diff, format_str, output_stream, args))\n            else:\n                version_match = PROTOCOL_VERSION_INDICATOR_RE.search(line)\n                if version_match:\n                    cpp_protocol_version = int(version_match[1])\n                    if cpp_protocol_version != PROTOCOL_VERSION:\n                        raise Exception(\n                            'Incompatible CTP versions: C++ v{} <-> Python v{}'.format(cpp_protocol_version,\n                                                                                       PROTOCOL_VERSION))\n                    not_available = False\n                    next(log)  # required from here\n                    next(log)  # warning: unused variable ...\n                    next(log)  # line | int version = Version;\n                    next(log)  # ...  |     ^~~~~~~\n                else:\n                    self._compiler_log.append(line)\n        if not_available:\n            self._printers.append(CompilerStatement('No CTP output found.\\n'))\n\n        self._clean_compiler_log_suffix()\n\n    def _process_compiler_log(self):\n        if self._print_compiler_log:\n            for cl in self._compiler_log:\n                self._printers.append(CompilerStatement(cl))\n        self._compiler_log = []\n\n    def _clean_compiler_log_prefix(self):\n        # Remove all in expansion related warnings.\n        while len(self._compiler_log) > 0 and IN_EXPANSION_OF_RE.match(self._compiler_log[-1]):\n            self._compiler_log.pop()\n\n        # Remove all in instantiation related warnings.\n        if len(self._compiler_log) > 0 and (\n                AT_GLOBAL_SCOPE_RE.match(\n                    self._compiler_log[-1]) or IN_FUNCTION_RE.match(self._compiler_log[-1])):\n            self._compiler_log.pop()\n        elif len(self._compiler_log) > 1 and IN_INSTANTIATION_OF_RE.match(self._compiler_log[-2]):\n            self._compiler_log.pop()\n            self._compiler_log.pop()\n\n        # Remove in file included from.\n        while len(self._compiler_log) > 0 and IN_FILE_INCLUDED_RE.match(self._compiler_log[-1]):\n            self._compiler_log.pop()\n\n        # Remove all in template arguments for type warnings.\n        while len(self._compiler_log) > 0 and IN_TEMPLATE_ARGUMENT_FOR_TYPE.match(self._compiler_log[0]):\n            self._compiler_log.pop(0)\n            self._compiler_log.pop(0)\n            self._compiler_log.pop(0)\n\n        self._process_compiler_log()\n\n    def _clean_compiler_log_suffix(self):\n        # Remove all in template arguments for type warnings.\n        while len(self._compiler_log) > 0 and IN_TEMPLATE_ARGUMENT_FOR_TYPE.match(self._compiler_log[0]):\n            self._compiler_log.pop(0)\n            self._compiler_log.pop(0)\n            self._compiler_log.pop(0)\n\n        # Remove in file included from.\n        while len(self._compiler_log) > 0 and IN_FILE_INCLUDED_RE.match(self._compiler_log[-1]):\n            self._compiler_log.pop()\n\n        self._process_compiler_log()\n\n    def _parse_print_log(self, log: Iterator[str]):\n        \"\"\"\n        Parses for the parameters in the print log.\n        :param log: the print log\n        :param type_prettifier: Prettifier for types\n        \"\"\"\n        stack: List = [[]]\n\n        def parse_value(type_of_value: str, number: int, indicator: Indicator):\n            \"\"\"\n            Logic of a shift-reduce parser.\n            :param type_of_value: the type of the value\n            :param number: a representation of the value as number\n            :param indicator: the indicator\n            :return:\n            \"\"\"\n            if indicator == Indicator.NaNFloat:\n                stack[-1].append(math.nan)\n            elif indicator == Indicator.PositiveInfinityFloat:\n                stack[-1].append(math.inf)\n            elif indicator == Indicator.NegativeInfinityFloat:\n                stack[-1].append(-math.inf)\n            elif indicator == Indicator.PositiveFloat:\n                stack.append(number)\n            elif indicator == Indicator.NegativeFloat:\n                stack.append(-number)\n            elif indicator == Indicator.FractionFloat:\n                num = stack.pop()\n                factor = 1 if num >= 0 else -1\n                num += factor * float(number) / math.pow(10, 18)\n                stack[-1].append(num)\n            elif indicator == Indicator.PositiveInteger:\n                if type_of_value == 'char':\n                    stack[-1].append(chr(number))\n                elif type_of_value == 'bool':\n                    stack[-1].append(bool(number))\n                else:\n                    stack[-1].append(number)\n            elif indicator == Indicator.NegativeInteger:\n                stack[-1].append(-number)\n            elif indicator == Indicator.Type:\n                stack[-1].append(self._type_prettifier.prettify(type_of_value))\n            elif indicator in [Indicator.ArrayBegin, Indicator.StringBegin, indicator.TupleBegin]:\n                stack.append([])\n            elif indicator == Indicator.ArrayEnd:\n                array = stack.pop()\n                stack[-1].append(array)\n            elif indicator == Indicator.StringEnd:\n                array = stack.pop()\n                stack[-1].append(''.join(array))\n            elif indicator == Indicator.TupleEnd:\n                array = stack.pop()\n                stack[-1].append(tuple(array))\n            elif indicator == Indicator.CustomFormatBegin:\n                pass\n            elif indicator == Indicator.CustomFormatEnd:\n                # Unpack tuple.\n                array = [*stack[-1].pop()]\n                # First element is format string.\n                stack[-1].append(array[0].format(*array[1:]))\n            else:\n                raise Exception('Unexpected indicator: {}'.format(int(indicator)))\n\n        type_to_print = None\n        for line in log:\n            # Find a print indicator followed by a value indicator.\n            if type_to_print:\n                value_match = VALUE_INDICATOR_RE.search(line)\n                if value_match:\n                    parse_value(type_to_print, int(value_match[1]), Indicator(int(value_match[2])))\n                    type_to_print = None\n                    continue\n            print_value_match = PRINT_INDICATOR_RE.match(line)\n            if print_value_match:\n                type_to_print = print_value_match[1]\n            elif type_to_print:\n                # Neither value indicator nor print indicator after a print indicator is an error.\n                raise Exception('No valid print statement: {}'.format(line))\n            elif END_INDICATOR_RE.search(line):\n                break\n        self._read_until_end_of_ctp_output(log)\n\n        if len(stack) != 1:\n            raise Exception('Incomplete print statement')\n        return stack.pop()\n\n    @staticmethod\n    def _read_until_end_of_ctp_output(log: Iterator[str]):\n        \"\"\"\n        Reads until the end of a fpermissive warning.\n        :param log: the print log\n        \"\"\"\n        try:\n            while True:\n                line = next(log)\n                if IN_EXPANSION_OF_CTP_MACRO_RE.match(line):\n                    next(log)\n                    next(log)\n                    break\n        except StopIteration:\n            return\n\n\ndef run_command(command: List[str], print_stdout: bool, return_code: List[int]) -> Iterator[str]:\n    \"\"\"\n    Runs the given command in a subprocess and returns the error log.\n    :param command: the command to run\n    :param print_stdout: flag to enable printing stdout\n    :param return_code: return/status/exit code of the ran command\n    :return: the error log\n    \"\"\"\n    if command:\n        prog = subprocess.Popen(command, stdout=None if print_stdout else subprocess.PIPE, stderr=subprocess.PIPE)\n\n        for line in prog.stderr:\n            yield line.decode('utf8')\n        return_code[0] = prog.wait()\n    else:\n        for line in sys.stdin:\n            yield line\n\n\ndef parse_args(args: List):\n    \"\"\"\n    Parses the command line parameters.\n    :param args: command line parameters\n    :return: `argparse.Namespace`: command line parameters namespace\n    \"\"\"\n\n    class DistinctType:\n        \"\"\"\n        Class is used to check if an argument was defaulted or not to improve error handling.\n        \"\"\"\n\n        def __init__(self, name):\n            self.__name = name\n\n        def __str__(self):\n            return self.__name\n\n    distinct_program = DistinctType('read from stdin')\n\n    parser = argparse.ArgumentParser(\n        prog='compile-time-parser',\n        description='Compile-time printer - prints variables and types at compile time in C++.',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n        usage='%(prog)s [optionals] [-- program args...]')\n    parser.add_argument('--version', action='version', version='compile-time-parser {ver}'.format(ver=__version__))\n    parser.add_argument('-r', '--remove', action='append', type=str,\n                        help='removes matching regex from type info', default=[])\n    parser.add_argument('-cr', '--capture-remove', action='append', type=str,\n                        help='removes matching regex but keeps first capture-group from type info', default=[])\n    parser.add_argument('--time-point', action='store_true',\n                        help='prints time point of each print statement')\n    parser.add_argument('--no-color', action='store_true',\n                        help='disables colored error output stream')\n    parser.add_argument('--hide-compiler-log', action='store_true',\n                        help=\"don't print unparsed compiler log\")\n    parser.add_argument('program', type=str, nargs='?',\n                        help='the program to compile the source', default=distinct_program)\n    parser.add_argument('args', type=str, nargs='*',\n                        help='the arguments for the command', default=[])\n    parser.add_argument('--dump-header-file', action='store_true',\n                        help='dumps the C++ header file to ctp/ctp.hpp')\n\n    # Arguments after '--' are the program and arguments called as subprocess.\n    # They are not passed to the argument parser and therefore have to be separated.\n    prog_and_args = None\n    try:\n        i = args.index('--')\n        prog_and_args = args[i + 1:]\n        args = args[:i]\n    except ValueError:\n        pass\n\n    options = parser.parse_args(args)\n    if options.program is not distinct_program:\n        parser.error('program and args must be placed after --')\n\n    options.prog_and_args = prog_and_args\n    return options\n\n\ndef dump_header_file():\n    p = Path('ctp')\n    p.mkdir(exist_ok=True)\n    data = pkgutil.get_data('compile_time_printer', 'include/ctp/ctp.hpp')\n    (p / 'ctp.hpp').write_bytes(data)\n\n\ndef main(args: List[str]):\n    \"\"\"\"\n    Main entry point allowing external calls.\n    :param args: command line parameter list\n    :param print_fct: function to print\n    \"\"\"\n    options = parse_args(args)\n\n    if options.dump_header_file:\n        dump_header_file()\n        print('Header file has been placed under ctp/ctp.hpp.')\n        return\n\n    # Run command.\n    return_code = [0]\n    log = run_command(options.prog_and_args, not options.hide_compiler_log, return_code)\n\n    # Parse output.\n    type_prettifier = TypePrettifier(options.remove, options.capture_remove)\n    ctp = CTP(type_prettifier, not options.hide_compiler_log)\n    try:\n        ctp.parse_error_log(log)\n    except Exception as e:\n        return_code[0] = e\n\n    # Iterate over printers and print.\n    for printer in ctp.printers:\n        printer.print(options.time_point, not options.no_color)\n    if return_code[0] != 0:\n        sys.exit(return_code[0])\n\n\ndef run():\n    \"\"\"\n    Entry point for console_scripts\n    \"\"\"\n    main(sys.argv[1:])\n\n\nif __name__ == '__main__':\n    run()\n"),t.runPython("import re\n\nCOMPILER_ERROR_WARNING_MESSAGE = re.compile(r'(<source>:)(\\d+)')\nCOMPILER_ERROR_WARNING_MESSAGE_DETAIL = re.compile(r'^([ ]+)(\\d+)([ ]+\\|[ ]+)')\n\n\nclass CTPHelper:\n    def __init__(self, include_offset):\n        self._include_offset = include_offset\n\n    def parse(self, log, show_compiler_log):\n        error = None\n        ctp = CTP(TypePrettifier([], []), show_compiler_log)  # noqa\n        try:\n            ctp.parse_error_log(iter(log))  # noqa\n        except Exception as e:\n            error = {'message': str(e), 'error_output': True, 'compiler_output': True}\n\n        result = []\n        for printer in ctp.printers:\n            result.append(self._prepare(printer))\n\n        if error:\n            result.append(error)\n        return result\n\n    def _prepare(self, printer):\n        message, error_output = printer.serialize()\n        if isinstance(printer, PrintStatement):  # noqa\n            return {'message': message, 'error_output': error_output, 'compiler_output': False}\n\n        # Fix line number for compiler messages.\n        [include_line_offset, include_line_nbr] = self._include_offset\n\n        def fix_line_number(match):\n            line_nbr = int(match[2])\n            # Logs before include.\n            if line_nbr <= include_line_nbr:\n                return match[1] + match[2]\n            # Logs in include.\n            if (line_nbr - include_line_offset) <= 0:\n                return match[1] + str(include_line_nbr)\n            # Logs after include.\n            return match[1] + str(line_nbr - include_line_offset)\n\n        def fix_line_number_detail(match):\n            line_nbr = int(match[2])\n            # Logs before include.\n            if line_nbr <= include_line_nbr:\n                return match[1] + match[2] + match[3]\n            # Logs in include.\n            new_line_nbr = line_nbr - include_line_offset\n            if new_line_nbr <= 0:\n                new_line_nbr = include_line_nbr\n            # Keep correct spacing.\n            new_line_nbr = str(new_line_nbr)\n            padding = len(match[1]) + len(match[2]) - len(new_line_nbr)\n            return ' ' * padding + new_line_nbr + match[3]\n\n        message, matched = COMPILER_ERROR_WARNING_MESSAGE.subn(fix_line_number, message)\n        if not matched:\n            message = COMPILER_ERROR_WARNING_MESSAGE_DETAIL.sub(fix_line_number_detail, message)\n        return {'message': message + '\\n', 'error_output': error_output, 'compiler_output': True}\n\n\ndef parse(include_offset, log, show_compiler_log):\n    return CTPHelper(include_offset).parse(log, show_compiler_log)\n"),o=t.globals.get("parse")}));const l=/#\s*include\s*<ctp\/ctp\.hpp>/,p=/#\s*include\s*<ctp\/ctp\.hpp>/g,_=a.split("\n").length-1;function c(t,e,n,r){let i,c;[c,r]=function(t){let e=-1;const n=t.split("\n");for(let t=0;t<n.length;t++)if(l.test(n[t])){e=t+1;break}return-1===e?[[0,0],t]:(t=(t=t.replace(l,a)).replaceAll(p,""),[[_,e],t])}(r);const d=new Promise((function(a,l){i=setTimeout((function(){(function(t,e,n){const r={source:n,options:{userArguments:e+" -fno-diagnostics-color -fsyntax-only"}};return fetch(`https://godbolt.org/api/compiler/${t}/compile`,{headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify(r),method:"POST"}).then((t=>t.json())).then((t=>[0===t.code,t.stderr.map((t=>t.text))]))})(t,e,r).then((([t,e])=>s.then((()=>[t,o(c,e,n).toJs()])))).then(a).catch(l)}),500)}));return{promise:d,cancel:function(){clearTimeout(i)}}}var d=n(6961),m=n.n(d),u=n(3400);const f=[["GCC trunk","gsnapshot"],["GCC 12.2","g122"],["GCC 12.1","g121"],["GCC 11.3","g113"],["GCC 11.2","g112"],["GCC 11.1","g111"],["GCC 10.4","g104"],["GCC 10.3","g103"],["GCC 10.2","g102"],["GCC 10.1","g101"],["GCC 9.3","g93"],["GCC 9.2","g92"],["GCC 9.1","g91"],["GCC 8.3","g83"],["GCC 8.2","g82"],["GCC 8.1","g81"],["GCC 7.5","g75"],["GCC 7.4","g74"]],g=/<source>:(\d+):(\d+): ((?:fatal )?error|warning):\s+(.+)/,h={code:'#include <ctp/ctp.hpp>\n\nstruct FooBar {\n\tint i;\n\tfloat j;\n};\n\ntemplate<>\nstruct ctp::formatter<FooBar> {\n\tstatic constexpr auto format(const FooBar& obj) {\n\t\treturn std::tuple{"(.i = {}, .j = {})", obj.i, obj.j};\n\t}\n};\n\nconstexpr auto test() {\n\tctp::print("Integral:");\n\tctp::print(true, 1, -2, std::numeric_limits<uint64_t>::max());\n\n\tctp::print("\\nFloating point:");\n\tctp::print(1.22F, std::numeric_limits<float>::infinity());\n\tctp::printf("{:.2f}\\n", 1.22F);\n\n\tctp::print("\\nArray:");\n\tstd::array<int, 5> arr{1, 5, 3, 2, 4};\n\tctp::print(arr);\n\tctp::printf("Third element is: {[2]}\\n", arr);\n\n\tctp::print("\\nView:");\n\tctp::print(ctp::view(arr.data() + 1, 3));\n\n\tctp::print("\\nTuple:");\n\tstd::tuple<int, double> tuple{1, 2.5};\n\tctp::print(tuple);\n\tctp::printf("Second element is: {[1]}\\n", tuple);\n\n\tctp::print("\\nPair:");\n\tstd::pair<int, double> pair{-3.5, 2};\n\tctp::print(pair);\n\n\tctp::print("\\nTypes:");\n\tctp::printf("Pair \'{}\' is not an alias of tuple \'{}\'.\\n", ctp::type<decltype(pair)>{}, ctp::type{tuple});\n\tctp::printf("But both have the same size: {} - {}\\n", sizeof(pair), sizeof(tuple));\n\n\tctp::print("\\nUser-defined type:");\n\tFooBar foobar{3, -1.25F};\n\tctp::print(ctp::type<FooBar>{}, foobar);\n\n\tctp::printf(ctp::stderr, "\\n\\tFatal ");\n\tctp::print(ctp::stderr, "success! :)");\n\n\t[[maybe_unused]] constexpr auto i = ctp::print("Print examples:\\n");\n\n\treturn true;\n}\n\nconstexpr auto t = test();\n',compiler:"g122",compiler_flags:"-fpermissive -std=c++17",show_compiler_log:!0};class y{constructor(t){this._data={...h},this._compiling=null,this._output_is_compiling=null,this._model=t,this._on_change=null,this._compiler_picker_select=document.getElementById("compiler-picker");for(const t of f)this._compiler_picker_select.options[this._compiler_picker_select.options.length]=new Option(t[0],t[1]);this._compiler_status=document.getElementById("compiler-status"),this._compiler_flags_input=document.getElementById("compiler-flags"),this._show_compiler_log_input=document.getElementById("show-compiler-log-input"),this._output_node=document.getElementById("output"),this._model.onDidChangeContent((()=>{this._data.code=this._model.getValue(),this.compile()})),this._compiler_picker_select.addEventListener("change",(t=>{this._data.compiler=t.target.value,this.compile()})),this._compiler_flags_input.addEventListener("input",(t=>{this._data.compiler_flags=t.target.value,this.compile()})),this._show_compiler_log_input.addEventListener("change",(t=>{this._data.show_compiler_log=t.target.checked,this.compile()}))}serialize(){return this._data}deserialize(t){if(t){for(const e of Object.keys(this._data))Object.prototype.hasOwnProperty.call(t,e)&&("boolean"==typeof this._data[e]?this._data[e]="true"===t[e]:this._data[e]=t[e]);this._update_ui()}}reset(){this._data={...h},this._update_ui()}register_on_change(t){this._on_change=t}_update_ui(){this._model.setValue(this._data.code);for(const t of this._compiler_picker_select.options)t.value===this._data.compiler&&(t.selected="selected");this._compiler_flags_input.value=this._data.compiler_flags,this._show_compiler_log_input.checked=this._data.show_compiler_log}compile(){this._on_change&&this._on_change(),clearTimeout(this._output_is_compiling),this._output_is_compiling=setTimeout((()=>{this._output_node.innerHTML="";const t=document.createElement("span"),e=document.createTextNode("<Compiling...>");t.classList.add("info"),t.appendChild(e),this._output_node.appendChild(t),this._compiler_status.style.color=null,this._compiler_status.classList.remove("fa-check-circle"),this._compiler_status.classList.add("fa-spinner")}),500),null!==this._compiling&&this._compiling.cancel(),this._compiling=c(this._data.compiler,this._data.compiler_flags,this._data.show_compiler_log,this._data.code),this._compiling.promise.then((([t,e])=>this._output(t,e)))}_output(t,e){clearTimeout(this._output_is_compiling),this._output_node.innerHTML="";let n=!1;const r=[];for(const t of e){const e=document.createElement("span"),i=document.createTextNode(t.get("message"));if(t.get("error_output")?e.classList.add("stderr"):e.classList.add("stdout"),e.appendChild(i),this._output_node.appendChild(e),t.get("compiler_output")){n=!0;const e=g.exec(t.get("message"));if(e){const t=parseInt(e[1]);if(t>this._model.getLineCount())continue;const n=this._model.getLineFirstNonWhitespaceColumn(t),i=this._model.getLineLastNonWhitespaceColumn(t),a="warning"===e[3]?2:3;r.push({severity:a,source:e[4],message:e[3],startLineNumber:t,startColumn:n,endLineNumber:t,endColumn:i})}}}this._compiler_status.style.color=null,t?this._compiler_status.classList.add("fa-check-circle"):this._compiler_status.classList.add("fa-times-circle"),this._compiler_status.style.color=n||!t?"rgb(255, 101, 0)":"rgb(18, 187, 18)",this._compiler_status.classList.remove("fa-spinner"),u.j6.setModelMarkers(this._model,"compilerId",r)}}class v{constructor(t){this._playground=t,this._save_playground=!0,this._short_link=!0;const e=document.getElementById("reset-btn");e.addEventListener("click",(t=>{this._playground.reset()})),this._share_link=document.getElementById("share-link"),document.getElementById("share-link-to-clipboard-btn").addEventListener("click",(t=>{navigator.clipboard.writeText(this._share_link.value)})),document.getElementById("share-link-length").addEventListener("change",(t=>{this._short_link="Short"===t.target.value,this._display_share_link()}));const n=document.getElementById("share-panel"),r=document.getElementById("open-share-panel-btn");n.style.top=r.offsetHeight+5+"px",r.addEventListener("click",(()=>{"visible"===n.style.visibility?n.style.visibility="hidden":(n.style.visibility="visible",this._display_share_link())})),window.addEventListener("click",(t=>{n.contains(t.target)||r.contains(t.target)||(n.style.visibility="hidden")}));const i=document.getElementById("github"),a=Math.max(i.offsetWidth,r.offsetWidth,e.offsetWidth)+"px";i.style.width=a,e.style.width=a,r.style.width=a,document.getElementById("header").style.height=document.getElementById("compiler-picker").offsetHeight+"px",this._playground.register_on_change((()=>this._save_to_storage()))}init(){let t=this._decode_share_url(window.location.href);t?this._save_playground=!1:t=this._load_from_storage(),this._playground.deserialize(t)}_load_from_storage(){const t={};for(const e of Object.keys(h)){const n=window.localStorage.getItem(e);null!==n&&(t[e]=n)}return t}_save_to_storage(){if(this._save_playground){const t=this._playground.serialize();for(const e of Object.keys(t))window.localStorage.setItem(e,t[e])}}_display_share_link(){const t=this._create_share_link(),e=location.protocol+"//"+location.host+location.pathname+t;this._short_link?(fetch("https://viatorus.pythonanywhere.com/short",{method:"POST",body:e}).then((t=>t.ok?t.text():"Failed to load.")).then((t=>{this._share_link.value=t})),this._share_link.value=""):this._share_link.value=e}_create_share_link(){const t=[];for(const[e,n]of Object.entries(this._playground.serialize()))t.push(`${e}=${encodeURIComponent(n)}`);return"#"+m().compressToBase64(t.join("&"))}_decode_share_url(t){const e=t.indexOf("#");if(e>=0){const n=m().decompressFromBase64(t.slice(e+1)),r={};for(const t of n.split("&")){const[e,n]=t.split("=");"string"==typeof n&&(r[e]=decodeURIComponent(n))}return r}return null}}!function(t){let e;const n=document.getElementById("editor-panel"),r=document.getElementById("output-panel");t.onmousedown=function(t){e={e:t,firstWidth:n.offsetWidth,secondWidth:r.offsetWidth},document.onmousemove=o,document.onmouseup=()=>{document.onmousemove=document.onmouseup=null}};const i=t.offsetWidth,a="% - "+i/2+"px)";function o(t){const o={x:t.clientX-e.e.clientX,y:t.clientY-e.e.clientY};o.x=Math.min(Math.max(o.x,-e.firstWidth),e.secondWidth);const s=e.firstWidth+o.x+i,l=e.secondWidth-o.x+2*i;n.style.width="calc("+s/window.innerWidth*100+a,r.style.width="calc("+l/window.innerWidth*100+a}}(document.getElementById("separator")),window.addEventListener("load",(t=>{const e=new y(i.getModel());new v(e).init(),e.compile(),document.getElementById("header").style.visibility=null,document.getElementById("playground").style.visibility=null}))}},t=>{t.O(0,[216],(()=>{return e=8886,t(t.s=e);var e}));t.O()}]);